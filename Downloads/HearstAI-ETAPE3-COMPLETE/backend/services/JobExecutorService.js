// Job Executor Service
// Executes jobs asynchronously with Claude API

const Job = require('../models/Job');
const Version = require('../models/Version');
const claudeAPI = require('./ClaudeAPIService');
const dbManager = require('../database/db');

class JobExecutorService {
    constructor() {
        this.runningJobs = new Map();
    }

    /**
     * Execute a job
     */
    async executeJob(jobId) {
        try {
            // Check if already running
            if (this.runningJobs.has(jobId)) {
                throw new Error('Job already running');
            }

            this.runningJobs.set(jobId, true);

            // Update job status to running
            Job.update(jobId, { status: 'running' });
            this.createLog(jobId, 'info', 'Job started');

            // Get job details
            const job = Job.getById(jobId);
            if (!job) {
                throw new Error('Job not found');
            }

            // Execute with Claude API
            this.createLog(jobId, 'info', 'Calling Claude API...');
            
            let result;
            if (claudeAPI.isConfigured()) {
                result = await claudeAPI.executeJob(job);
            } else {
                // Use simulation if no API key
                this.createLog(jobId, 'warning', 'Using simulated Claude API (no API key configured)');
                result = await claudeAPI.simulateJob(job);
            }

            if (result.success) {
                // Create new version with output
                const newVersion = await this.createOutputVersion(job, result.output);
                
                // Update job with success
                Job.update(jobId, {
                    status: 'success',
                    output_summary: this.truncateOutput(result.output),
                    output_version_id: newVersion.id
                });

                this.createLog(jobId, 'success', `Job completed successfully. Created ${newVersion.label}`);
            } else {
                // Update job with failure
                Job.update(jobId, {
                    status: 'failed',
                    error_message: result.error
                });

                this.createLog(jobId, 'error', `Job failed: ${result.error}`);
            }

            this.runningJobs.delete(jobId);
            return result;

        } catch (error) {
            console.error('Job execution error:', error);
            
            Job.update(jobId, {
                status: 'failed',
                error_message: error.message
            });

            this.createLog(jobId, 'error', `Job failed: ${error.message}`);
            this.runningJobs.delete(jobId);
            
            throw error;
        }
    }

    /**
     * Create output version from job result
     */
    async createOutputVersion(job, output) {
        // Generate next version label
        const nextLabel = Version.generateNextLabel(job.project_id);

        // Create version
        const version = Version.create({
            project_id: job.project_id,
            label: nextLabel,
            description: `Generated by ${job.type} job`,
            created_by_job_id: job.id,
            metadata: {
                job_type: job.type,
                generated_by_claude: true
            }
        });

        // Save output as file
        // For now, we save the entire output as a single file
        // In a real scenario, you'd parse the output and create proper files
        const fileData = {
            path: `output_${job.type}.txt`,
            filename: `output_${job.type}.txt`,
            extension: 'txt',
            size_bytes: Buffer.byteLength(output),
            content_hash: require('crypto').createHash('sha256').update(output).digest('hex'),
            storage_path: `${version.project_id}/${nextLabel}/output_${job.type}.txt`
        };

        // Save to storage
        const fileStorage = require('./FileStorageService');
        fileStorage.saveFile(job.project_id, nextLabel, fileData.path, output);

        // Add to database
        Version.addFile(version.id, fileData);

        return version;
    }

    /**
     * Create log entry
     */
    createLog(jobId, level, message) {
        const db = dbManager.getDb();
        const job = Job.getById(jobId);
        
        db.prepare(`
            INSERT INTO log_entries (id, job_id, project_id, level, message, timestamp, metadata)
            VALUES (?, ?, ?, ?, ?, ?, ?)
        `).run(
            require('uuid').v4(),
            jobId,
            job.project_id,
            level,
            message,
            new Date().toISOString(),
            '{}'
        );
    }

    /**
     * Truncate output for summary
     */
    truncateOutput(output, maxLength = 500) {
        if (output.length <= maxLength) {
            return output;
        }
        return output.substring(0, maxLength) + '... (truncated)';
    }

    /**
     * Execute job in background
     */
    executeJobAsync(jobId) {
        // Execute without waiting
        this.executeJob(jobId).catch(error => {
            console.error('Background job execution failed:', error);
        });
    }
}

module.exports = new JobExecutorService();
